{% extends "layout.html" %}

{% block content %}
<div class="main-visualization">
    <h1 class="vis-title">Data Visualization</h1>
    <div class="main">
        <!-- Chart Display Section -->
        <div class="main-canvas">
            <!-- Tab Navigation -->
            <div class="tabs-vis">
                <button class="tab-vis active-tab" id="bar-chart-tab">Bar Chart</button>
                <button class="tab-vis" id="bubble-chart-tab">Bubble Chart</button>
                <button class="tab-vis" id="histogram-tab">Histogram</button>
                <button class="tab-vis" id="pie-chart-tab">Pie Chart</button>
                <button class="tab-vis" id="radar-chart-tab">Radar Chart</button>
            </div>
            <!-- Canvas for Charts -->
            <div class="canvas">
                <canvas id="bar-chart" class="chart"></canvas>
                <canvas id="bubble-chart" class="chart hidden"></canvas>
                <canvas id="histogram" class="chart hidden"></canvas>
                <canvas id="pie-chart" class="chart hidden"></canvas>
                <canvas id="radar-chart" class="chart hidden"></canvas>
            </div>
        </div>

        <!-- Customization Panel -->
        <div class="tabs-cust">
            <div class="customization">
                <h2 class="cust-title">Customize Charts</h2>

                <!-- Common Customization -->
                <label for="x-axis">X-Axis:</label>
                <select id="x-axis"></select>

                <label for="y-axis">Y-Axis:</label>
                <select id="y-axis"></select>

                <div class="btns">
                    <button class="apply-btn" id="apply-customization">Apply</button>
                    <button id="generate-palette" class="btn btn-primary">Generate Color</button>
                    <button class="apply-btn" id="download-image">Download Image</button>
                    <button class="apply-btn" id="generate-pdf">Generate Report (PDF)</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.4.0/jspdf.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/google-generativeai"></script>

<script>
    // Large Dataset Optimization Utilities
    const DataProcessor = {
        // Sampling strategy for large datasets
        sampleData(data, maxSamples = 1000) {
            if (data.length <= maxSamples) return data;

            const sampleStep = Math.floor(data.length / maxSamples);
            return data.filter((_, index) => index % sampleStep === 0);
        },

        // Aggregate data for summary visualizations
        aggregateData(data, aggregationType = 'mean') {
            switch(aggregationType) {
                case 'mean':
                    return data.reduce((a, b) => a + b, 0) / data.length;
                case 'median':
                    const sorted = [...data].sort((a, b) => a - b);
                    const middle = Math.floor(sorted.length / 2);
                    return sorted.length % 2 
                        ? sorted[middle] 
                        : (sorted[middle - 1] + sorted[middle]) / 2;
                case 'binning':
                    const min = Math.min(...data);
                    const max = Math.max(...data);
                    const binCount = 10;
                    const binSize = (max - min) / binCount;
                    return data.reduce((bins, value) => {
                        const binIndex = Math.min(
                            Math.floor((value - min) / binSize), 
                            binCount - 1
                        );
                        bins[binIndex] = (bins[binIndex] || 0) + 1;
                        return bins;
                    }, new Array(binCount).fill(0));
            }
        },

        // Debounce function to prevent multiple rapid renders
        debounce(func, delay) {
            let timeoutId;
            return (...args) => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => func.apply(this, args), delay);
            };
        }
    };

    // Main Visualization Controller
    const VisualizationController = {
        activeTab: 'bar-chart',
        activeChart: null,
        chartData: null,

        // Initialize the visualization
        init(data) {
            this.chartData = JSON.parse(data);
            this.setupDropdowns();
            this.setupEventListeners();
            this.renderDefaultChart();
        },

        // Populate axis dropdowns
        setupDropdowns() {
            const xAxisDropdown = document.getElementById('x-axis');
            const yAxisDropdown = document.getElementById('y-axis');

            // Clear existing options
            xAxisDropdown.innerHTML = '';
            yAxisDropdown.innerHTML = '';

            // Populate dropdowns
            this.chartData.columns.forEach(column => {
                const xOption = document.createElement('option');
                xOption.value = column;
                xOption.textContent = column;
                xAxisDropdown.appendChild(xOption);

                const yOption = document.createElement('option');
                yOption.value = column;
                yOption.textContent = column;
                yAxisDropdown.appendChild(yOption);
            });

            // Set default selections
            if (this.chartData.columns.length > 0) {
                xAxisDropdown.value = this.chartData.columns[0];
                yAxisDropdown.value = this.chartData.columns[1] || this.chartData.columns[0];
            }
        },

        // Set up event listeners
        setupEventListeners() {
            // Tab navigation
            document.querySelectorAll('.tab-vis').forEach(tab => {
                tab.addEventListener('click', () => {
                    this.activeTab = tab.id.replace('-tab', '');
                    this.switchTab();
                });
            });

            // Customization apply button
            document.getElementById('apply-customization').addEventListener('click', 
                DataProcessor.debounce(() => this.renderChartBasedOnActiveTab(), 300)
            );

            // Color palette generation
            document.getElementById('generate-palette').addEventListener('click', () => {
                const paletteColors = this.generateRandomColors(10);
                this.applyPaletteToChart(paletteColors);
            });

            // Image download
            document.getElementById('download-image').addEventListener('click', () => {
                if (this.activeChart) {
                    const imageUrl = this.activeChart.toBase64Image();
                    const link = document.createElement('a');
                    link.href = imageUrl;
                    link.download = `${this.activeTab}-chart-image.png`;
                    link.click();
                }
            });
        },

        // Switch active tab and render chart
        switchTab() {
            document.querySelectorAll('.chart').forEach(c => c.classList.add('hidden'));
            document.getElementById(this.activeTab).classList.remove('hidden');
            this.renderChartBasedOnActiveTab();
        },

        // Render chart based on active tab
        renderChartBasedOnActiveTab() {
            const xAxis = document.getElementById('x-axis').value;
            const yAxis = document.getElementById('y-axis').value;

            // Show loading indicator
            this.showLoadingIndicator();

            // Render specific chart type
            switch (this.activeTab) {
                case 'bar-chart': 
                    this.renderOptimizedBarChart(xAxis, yAxis); 
                    break;
                case 'bubble-chart': 
                    this.renderOptimizedBubbleChart(xAxis, yAxis); 
                    break;
                case 'histogram': 
                    this.renderOptimizedHistogram(xAxis, yAxis); 
                    break;
                case 'pie-chart': 
                    this.renderOptimizedPieChart(xAxis, yAxis); 
                    break;
                case 'radar-chart': 
                    this.renderOptimizedRadarChart(xAxis, yAxis); 
                    break;
            }
        },

        // Optimized Bar Chart Rendering
        renderOptimizedBarChart(xAxis, yAxis) {
            const ctx = document.getElementById('bar-chart').getContext('2d');
            
            // Sample data for large datasets
            const xData = DataProcessor.sampleData(this.chartData.data[xAxis]);
            const yData = DataProcessor.sampleData(this.chartData.data[yAxis]);
            
            // Generate optimized colors
            const colors = this.generateRandomColors(xData.length);

            // Destroy previous chart
            if (this.activeChart) this.activeChart.destroy();

            // Create new chart with performance optimizations
            this.activeChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: xData,
                    datasets: [{
                        label: `${xAxis} vs ${yAxis}`,
                        data: yData,
                        backgroundColor: colors
                    }]
                },
                options: { 
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: { duration: 0 }, // Disable animations for performance
                    plugins: {
                        legend: { position: 'top' }
                    }
                }
            });
        },

        // Similar optimization methods for other chart types...
        renderOptimizedBubbleChart(xAxis, yAxis) {
            const ctx = document.getElementById('bubble-chart').getContext('2d');
            
            // Sample and process data
            const xData = DataProcessor.sampleData(this.chartData.data[xAxis]);
            const yData = DataProcessor.sampleData(this.chartData.data[yAxis]);
            
            const bubbleData = xData.map((x, i) => ({
                x, 
                y: yData[i], 
                r: Math.min(Math.abs(yData[i]) * 2, 20) // Limit bubble size
            }));

            const colors = this.generateRandomColors(bubbleData.length);

            if (this.activeChart) this.activeChart.destroy();

            this.activeChart = new Chart(ctx, {
                type: 'bubble',
                data: {
                    datasets: [{
                        label: `${xAxis} vs ${yAxis}`,
                        data: bubbleData,
                        backgroundColor: colors
                    }]
                },
                options: { 
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: { duration: 0 },
                    plugins: {
                        legend: { position: 'top' }
                    }
                }
            });
        },

        // Add these methods to the VisualizationController object

renderOptimizedHistogram(xAxis, yAxis) {
    const ctx = document.getElementById('histogram').getContext('2d');
    
    // Sample and bin the data
    const data = DataProcessor.sampleData(this.chartData.data[xAxis]);
    const binnedData = DataProcessor.aggregateData(data, 'binning');
    
    // Generate bin labels
    const min = Math.min(...data);
    const max = Math.max(...data);
    const binSize = (max - min) / binnedData.length;
    const labels = binnedData.map((_, index) => {
        const binStart = min + index * binSize;
        const binEnd = binStart + binSize;
        return `${binStart.toFixed(2)} - ${binEnd.toFixed(2)}`;
    });

    const colors = this.generateRandomColors(binnedData.length);

    if (this.activeChart) this.activeChart.destroy();

    this.activeChart = new Chart(ctx, {
        type: 'bar', // Histogram uses bar chart type
        data: {
            labels: labels,
            datasets: [{
                label: `${xAxis} Distribution`,
                data: binnedData,
                backgroundColor: colors
            }]
        },
        options: { 
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 0 },
            scales: {
                y: {
                    title: {
                        display: true,
                        text: 'Frequency'
                    }
                }
            },
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: `Histogram of ${xAxis}`
                }
            }
        }
    });
},

renderOptimizedPieChart(xAxis, yAxis) {
    const ctx = document.getElementById('pie-chart').getContext('2d');
    
    // Sample and aggregate data
    const labels = DataProcessor.sampleData(this.chartData.data[xAxis]);
    const values = DataProcessor.sampleData(this.chartData.data[yAxis]);
    
    // Aggregate similar categories
    const aggregatedData = labels.reduce((acc, label, index) => {
        if (acc[label]) {
            acc[label] += values[index];
        } else {
            acc[label] = values[index];
        }
        return acc;
    }, {});

    const aggregatedLabels = Object.keys(aggregatedData);
    const aggregatedValues = Object.values(aggregatedData);

    const colors = this.generateRandomColors(aggregatedLabels.length);

    if (this.activeChart) this.activeChart.destroy();

    this.activeChart = new Chart(ctx, {
        type: 'pie',
        data: {
            labels: aggregatedLabels,
            datasets: [{
                data: aggregatedValues,
                backgroundColor: colors
            }]
        },
        options: { 
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 0 },
            plugins: {
                legend: { position: 'bottom' },
                title: {
                    display: true,
                    text: `Pie Chart: ${xAxis} vs ${yAxis}`
                }
            }
        }
    });
},
        renderOptimizedRadarChart(xAxis, yAxis) {
            const ctx = document.getElementById('radar-chart').getContext('2d');
            
            // Sample data with max 10 categories to keep radar chart readable
            const labels = DataProcessor.sampleData(this.chartData.data[xAxis], 10);
            const values = DataProcessor.sampleData(this.chartData.data[yAxis], 10);
            
            // Normalize values to 0-100 range for better radar chart visualization
            const maxValue = Math.max(...values);
            const normalizedValues = values.map(val => Math.round((val / maxValue) * 100));

            const colors = this.generateRandomColors(1)[0];

            if (this.activeChart) this.activeChart.destroy();

            this.activeChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `${xAxis} vs ${yAxis}`,
                        data: normalizedValues,
                        backgroundColor: colors + '33', // Add transparency
                        borderColor: colors,
                        borderWidth: 1
                    }]
                },
                options: { 
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: { duration: 0 },
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 100
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Radar Chart: ${xAxis} Comparison`
                        }
                    }
                }
            });
        },

        // Show loading indicator during chart rendering
        showLoadingIndicator() {
            const canvas = document.getElementById(this.activeTab);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Loading data...', canvas.width / 2, canvas.height / 2);
        },

        // Generate random color palette
        generateRandomColors(count) {
            return Array.from({length: count}, () => {
                const hue = Math.random() * 360;
                const saturation = 70 + Math.random() * 30;
                const lightness = 40 + Math.random() * 20;
                return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            });
        },

        // Apply color palette to current chart
        applyPaletteToChart(colors) {
            if (!this.activeChart) return;

            const chartData = this.activeChart.data;
            if (chartData.datasets && chartData.datasets[0]) {
                chartData.datasets[0].backgroundColor = colors.slice(0, chartData.datasets[0].data.length);
                this.activeChart.update();
            }
        },

        // Render default chart on initialization
        renderDefaultChart() {
            this.activeTab = 'bar-chart';
            this.renderChartBasedOnActiveTab();
        }
    };

    // Initialize visualization when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
        VisualizationController.init('{{ chart_data | safe }}');
    });
</script>

{% endblock %}
